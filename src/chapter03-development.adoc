[#chapter03-development]
== Développement de la plateforme

Étant le seul développeur _back-end_, il m’a fallut m’organiser afin d’optimiser au maximum mon temps.

=== Développement Dirigé par les Test

Selon moi, une des façon d’optimiser son développement est d’assurer ses arrières afin d’éviter de corriger des bogues. Pour cela, ma solution est les tests unitaires footnote:[Les test unitaires sont du code qui permet de vérifier le comportement de certaines parties du code afin de vérifier qu’il n’y a pas de changements indésirables lors d’un développement]. Afin de pérenniser l'application, je me suis imposé deux méthodologies:

* le _Test Driven Development_ (Développement Dirigé par les Test dans la langue de molière). Il s’agit de commencer par développer le test avant de développer la fonctionnalité.
* couvrir d’un test chaque bogues relevé

Il s’agit de deux règles simples mais elles m’ont permit d’obtenir une couverture de code de l’ordre de 90% en moyenne.

=== Exemple de test unitaires

NOTE: Vous aurez l’occasion de découvrir comment j’ai pu mettre en place un test unitaire lors de l’élaboration de la fonctionnalité de suppression d’un utilisateur plus loin.

=== Exemple de test fonctionnels

Exemple, pour la page qui s’occupe d’afficher un utilisateur, j’ai choisis de coder quatres tests qui vont couvrir tous les cas:

* un avocat peut accéder à son profil
* un administrateur peut accéder au profil d’un avocat
* un utilisateur connecté ne peut pas accéder au profil d’un autre utilisateur
* un utilisateur non-connecté ne peut pas accéder au profil d’un autre utilisateur

Cela peut sembler paranoïaque, mais cela m’assure qu’aucune régression n’est possible sur cette page

[source, ruby]
----
class UsersControllerTest < ActionDispatch::IntegrationTest
  # ...
  test 'should show for connected user' do
    login(@advocate)
    get advocate_url(@advocate)
    assert_response :success
  end

  test 'should show for admin' do
    login(users(:super_user))
    get advocate_url(@advocate)
    assert_response :success
  end

  test 'should forbid show user for other user' do
    login(users(:one_other_advocate))
    get advocate_url(@advocate)
    assert_response :forbidden
  end

  test 'should forbid show user for non-connected user' do
    get advocate_url(@advocate)
    assert_response :forbidden
  end
  # ...
end
----

=== Mise en place de l’environnement de développement

Utilisation de https://rvm.io[RVM] (Ruby Version Manager) en local afin de reproduire un environnement de développement au plus près du serveur de production et de fixer la version de Ruby utilisée .

Création d’une machine virtuelle avec https://www.vagrantup.com[Vagrant] pour le designer qui développe sous Windows.

Création d’un dépôt Gitea auto-hébergé sur un Raspberry PI afin de travailler tous ensemble

=== Utilisation de l'API de Stripe

J'ai voulu implémenter la fonctionnalité d'**accès restreint** au site uniquement si l'utilisateur bénéficie d'un **compte premium**. Le but final est que l’utilisateur doive souscrire un compte premium afin d'accéder à certaines pages.

Afin d'implémenter cette fonctionnalité, nous avons commencé par analyser le besoin. Le comportement attendu est le suivant:

1. le client bénéficie d'un mois de découverte de notre outil dès son inscription
2. une fois son _solde de jours premium_ épuisé, il reçoit un mail lui indiquant qu'il va falloir racheter des jours
3. l'utilisateur met à jour son solde en effectuant un **paiement ponctuel** qui lui rajoute un mois à son solde premium où il souscrit un abonnement qui effectuera un **paiement automatique** au début de chaque mois

Afin d'implémenter cela, j'ai rapidement fait le tour des solutions de paiement existantes (PayPal, BNP, etc..). Il s'est avéré que https://stripe.com[Stripe] était le meilleur compromis.

NOTE: Stripe est une société américaine qui a pour but de simplifier les paiements en ligne. Créée en 2010, Stripe pèse maintenant plus de 10 milliards!

J'ai choisi Stripe car ses avantages sont:

- le client peut payer sans avoir un compte ouvert chez Stripe
- les tarifs sont assez "raisonnables" _(1,4% + 0,25€ par transaction pour les cartes européennes)_
- la facilité de la mise en place car, en plus de proposer une belle API, Stripe propose des librairies pour les langages les plus utilisés (https://github.com/stripe/stripe-php[PHP], https://github.com/stripe/stripe-python[Pyhton], https://github.com/stripe/stripe-ruby[Ruby], https://github.com/stripe/stripe-java[Java] et même https://github.com/stripe/stripe-go[Go])
- une https://stripe.com/docs[excellente documentation]

De plus, Stripe va bien plus loin qu'une _simple_ solution de paiement puisqu'il propose tout un écosystème pour gérer des clients, des factures, des produits, etc...

Dans cet article je vais donc retracer le développement de la fonctionnalité en essayant d'être le plus générique possible. Je précise aussi avant de commencer que ce n'est pas un article sponsorisé et je n'ai pas reçu d'argent de la part de Stripe (j'aurais bien voulu...).

// TODO

=== Migration vers une architecture API
