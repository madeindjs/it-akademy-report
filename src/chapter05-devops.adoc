[#chapter05-devops]
== Mise en production

Étant dans une startup, mon travail ne s'est pas cantonné à du développement logiciel mais aussi à l'administration d'un serveur Linux. Dans ce chapitre je vais retracer certaines actions que j'ai effectué afin d'installer et de sécuriser mon serveur.

Néanmoins, mon travail au seins de iSignif ne se résume pas à celle -ci car je m'occupe aussi de la maintenant de celui-ci.

=== Choix du serveur

Le choix du serveur a beaucoup de conséquence pour l'entreprise. Plusieurs solutions existent:

* Le serveur *mutualisé*: Il s’agit d’un serveur que l’on partage avec d’autres client afin de réduire le coût. L’inconvénient est que nous n’avons pas le choix sur les librairies installées ni sur les logiciels.
* Le serveur *dédié*: L’avantage est le contrôle total sur le serveur mais l’inconvénient est que ce n’est pas évolutif. Si on veut augmenter les performances, il faut passer sur un autre serveur dédie.
* Un *VPS* _(Virtual Private Serveur)_: Il s’agit d’un container placé sur un serveur. L’avantage est qu’à tout moment on peut déplacer le container sur un serveur plus puissant et ainsi s’adapter à une charge élevée. L’inconvénient est que le stockage est très cher.
* Un fournisseur *PAAS* _(Product As A Service)_, le déploiement se fait instantanément sans tenir compte de la partie hardware. Le fournisseur réalise l’administration du serveur. En revanche le coût est plus élevé (à partir de 25 euros / mois)

Pour mon application j’ai choisi le VPS qui me permet d’administrer mon serveur comme je le souhaite tout en réduisant le coût. Étant dans une phase de validation du concept, ce choix m’a permis de commencer avec un petit serveur à 3 euros / mois . Lors de la validation du concept, je pourrais basculer sur un serveur plus puissant très facilement.

=== Installation

==== Serveur

OVH donne les choix entre plusieurs OS et plusieurs distributions. Mon choix s’est porté sur *Ubuntu 18.04 server*. Une fois le serveur mis en place, la première étape est de sécuriser dès le début l’utilisation. J’ai donc créé un utilisateur spécifique qui me servira uniquement le déploiement de l’application.

Je le rajoute dans les `sudoers` (Groupes d’utilisateur possédants les droits administrateur) uniquement afin de simplifier la construction de l’environnement de production.

.Création d'un utilisateur spécifique sur le serveur
[source,bash]
----
$ sudo adduser isignif
$ passwd isignif
$ sudo addgroup isignif sudo
----

Une fois l’utilisateur crée, j’ai crée une clé SSH pour me connecter sans mot de passe et j’ai désactivé la possibilité de se connecter au compte `root` via SSH. Ainsi il est est impossible de réaliser une attaque par tentative de bibliothèque de mot de passe (_bruteforce_).

Concernant les paquets à installer, tout est déjà présent dans les repertoires officiels de Ubuntu. J'ai donc choisis d'installer:

- `apache2` pour le serveur web
- `nodejs` pour la minification des fichiers JavaScript
- `git` pour la mise en production
- `mariadb-server libmariadb-dev`

Je n'ai pas installé le paquet `ruby`. J’ai choisi d’utiliser *Ruby Version Manager* (RVM) . RVM possède l’avantage de pouvoir installer exactement la version de Ruby souhaitée. Mais surtout, RVM permet de cloisonner les gemmes (librairies Ruby) à l’utilisateur courant et non à l’administrateur `root`. Ceci permet de réduire les risques d’escalade de droits.

==== Base de donné

Concernant la SGBD _(Système de Gestion de Base de Données)_, Ruby on Rails ne pose pas de contrainte particulière. J’ai donc choisi MariaDB. Une fois installé, je lance directement le script de sécurisation de l’installation:

.Script de sécurisation d'un serveur MariaDB
[source,bash]
----
$ mysql_secure_installation
----

Ce script permet de:

* mettre un mot de passe pour l’utilisateur `root` (Administrateur)
* supprimer les utilisateur anonymes
* désactiver la possibilité aux utilisateur `root` de pouvoir se connecter

Toujours dans un soucis de gestion fine des droits, j’ai choisi de créer un utilisateur MariaDB spécifique à l’application. Cela permet

.Création d'une base de données et d'un utilisateur spécifique
[source,sql]
----
MariaDB > CREATE DATABASE isignif DEFAULT CHARACTER set utf8   default COLLATE utf8_general_ci;
MariaDB > CREATE USER 'isignif'@'localhost' IDENTIFIED BY '****';
MariaDB > GRANT ALL PRIVILEGES ON isignif . * TO 'isignif'@'localhost';
----


=== Sécurité

Aujourd’hui, la sécurité informatique est un enjeu majeur. D’autant plus pour iSignif qui manipules des données sensibles. Il faut un certains temps pour bâtir une réputation et une fuite de données peut suffire à la ruiner (Mars 2017, Facebook à perdu 37 milliards de dollars suite à la révélation de la fuite des données de plus de 50 millions de leurs utilisateurs https://www.lci.fr/high-tech/affaire-cambridge-analytica-quel-est-ce-scandale-qui-plonge-facebook-dans-la-crise-mark-zuckerberg-2082228.html[selon LCI]].

==== Sécurité de l’application

Dans un premier temps, la sécurité passe par l’application. L’application doit être robuste et imperméables aux attaques les plus connues. Heureusement, Ruby on Rails étant un framework éprouvé, il prévient des failles de sécurité les plus connues (pour peu qu’on respecte sa façon de coder).

Par exemple, le *Cross-site Scripting* permet d'envoyer un formulaire provenant d’un autre site vers le nôtre. Rails utilise un jeton qu’il place sur tous les formulaires et il peut identifier les formulaires qui lui sont propre.

L’*injection SQL* consiste à injecter du code SQL (utilisé pour envoyer des requêtes sur la base de données). Comme le montre la figure suivante, les injection SQL sont très faciles. Heureusement, Rails échappe par défaut tous les paramètres envoyés par l’utilisateur.

.Une tentative d’injection SQL sur un formulaire de contact
image:sql_injection.png[sql_injection, 250]

L'**injection de code JavaScript** permet d’exécuter du code JavaScript sur le navigateur du client. Cette faille est simplissime, par exemple, un petit malin peut créer un utilisateur contenant du code JavaScript comme nom de famille `<script>alert('Pwned')</script>`. Alors sur chaque page ou son nom sera affiché, le code sera exécuté. Heureusement, Rails nous protège directement de cela en échappant les caractères.

En continuant sur les failles classiques, je peux évoquer l'**attaque par force brute**. Il s’agit de tenter de se connecter plusieurs fois en utilisant un login et un dictionnaire de mots de passe. Dans mon cas, j’ai utilisé la bibliothèque https://github.com/binarylogic/authlogic[Authlogic] qui stocke le nombre de tentative de connections échouées dans la base de données. Ainsi, une fois 3 tentatives dépassées, le compte est bloqué et il n’est plus possible de se connecter avec le login.

===== Les failles les plus récentes

Des failles de sécurités sont découvertes tous les jours. Heureusement pour nous, une organisation les répertories. Ces vulnérabilités sont identifiées par un identifiant CVE (Common Vulnerabilities and Exposures).

https://github.com/rubysec/ruby-advisory-db[Ruby Advisory Database] est une base de données communautaire qui s’appuie sur ces CVE. Elle répertorie les bibliothèques Ruby vulnérables à ces CVE. Des outils existent pour vérifier automatiquement que notre application n’utilise pas un bibliothèque vulnérable: https://github.com/rubysec/bundler-audit[Bundler Audit]. Cette gemme s’utilise très facilement:

.Exemple d'utilisation de Bundler Audit
[source,bash]
----
$ bundle audit
Name: actionpack
Version: 3.2.10
Advisory: OSVDB-91452
Criticality: Medium
URL: http://www.osvdb.org/show/osvdb/91452
Title: XSS vulnerability in sanitize_css in Action Pack
Solution: upgrade to ~> 2.3.18, ~> 3.1.12, >= 3.2.13
----

==== Audit de sécurité

Dans cette section, je vais vous détailler comment j'ai réalisé un audit complet de mon serveur moi-même en faisant des tests d'intrusion.

===== Vérifier les ports ouverts

La première étape pour un hacker est la *reconnaissance de la cible*. Cette étape consiste à obtenir le maximum d’informations sur la victime. Nous devons donc cacher le plus d’informations possible à propos de notre serveur.

Une des information facile à obtenir pour un hacker est les port ouverts sur le serveur. Les ports sont en quelques sortent des portes ouvertes sur le réseaux. Donc, dans un premier temps, j’ai simplement effectué un scan des ports sur mon serveur.

NOTE: Malgré sur ce qu’on peut entendre, le scan de port est tout à fait légal car il permet simplement de récupérer des informations publiques.

.Exemple d'utilisation de NMAP pour vérifier les ports ouverts
[source,bash]
----
$ sudo nmap isignif.fr -A

Starting Nmap 7.60 ( https://nmap.org ) at 2018-11-16 11:25 CET
Nmap scan report for isignif.fr (51.75.24.68)
...
PORT     STATE    SERVICE      VERSION
21/tcp   open     tcpwrapped
22/tcp   open     ssh          OpenSSH 7.6p1 Ubuntu 4ubuntu0.1 (Ubuntu Linux; protocol 2.0)
...
80/tcp   open     http         Apache httpd 2.4.29
...
443/tcp  open     ssl/ssl      Apache httpd (SSL-only mode)
...
Running (JUST GUESSING): Linux 3.X|4.X (86%), FreeBSD 6.X (85%)
...
----

On voit donc que beaucoup d’informations ressortent du scan comme:

* l’utilisation d’OpenSSH port 22 avec la version du logiciel
* l’utilisation d’Apache HTTPD port 22 / 443  avec la version du logiciel

NMAP nous fournis aussi le numéro de la version des logiciels utilisés. Cela peut servir à trouver des vulnérabilités. Je vous montrerai comment j’ai masqué certains de ses informations plus loin.

===== Réalisation d’un scan de vulnérabilité

Afin de connaître les vulnérabilité de mon installation, j’ai décidé de faire un scan de vulnérabilité en utilisant https://www.metasploit.com/[Metasploit]. Metasploit Framework est un logiciel écrit en Ruby permettant le développement et l’utilisation d’exploit. Les exploits sont des vulnérabilités qui permettent d’exécuter du code sur une machine distante. J'ai aussi utilisé et http://www.openvas.org/[OpenVAS], un scanner de vulnérabilités libre issu du fork de Nessus. OpenVAS s’appuie sur les https://cve.mitre.org/[CVE (Common Vulnerabilities and Exposures)]. Il s’agit d’une base de données des vulnérabilités connues.

NOTE: Le scan de vulnérabilité est illégal à moins que le serveur nous appartienne ou bien qu’une autorisation du propriétaire est donné. Dans mon cas, le serveur m’appartiens.

Plusieurs types de scan sont possibles, j’ai choisis d’utiliser le plus complet, qui est aussi le plus long. J’ai donc obtenu le résultat que l’on peu voir sur la figure suivant (le rapport complet est disponible en annexe).

.Capture d’écran du rapport de scan d’OpenVAS
image:kali_openvas_report.png[kali_openvas_report]

On peut voir que globalement mon serveur possède peu de vulnérabilités. Ceci est sûrement du au fait que je met à jours les paquets quotidiennement et que donc, les logiciels sont à jours.

==== Sécurité du serveur

Sécuriser un serveur est un travail à part entière qui nécessite beaucoup compétences. De plus, absolument personne ne peut se narguer d’être invulnérable aux tentatives d’attaques. Je n’ai pas la prétention d’être un expert en sécurité donc il s’agit ici de mettre en places les protections de base.

===== Utilisation du protocole HTTPS

Le https://fr.wikipedia.org/wiki/HyperText_Transfer_Protocol_Secure[protocole HTTPS] permet de chiffrer les communications entre le client et le serveur. Cela garantie que les informations qui transitent ne peuvent pas être lues par un attaquant. Ainsi, on protège les identifiants qui transite lorsqu’un utilisateur connecté.

Auparavant, il fallait souvent payer une entreprise qui garantissait la validité de la clé de chiffrement. L’activer se fait désormais très facilement grâce à https://letsencrypt.org/[Let’s encrypt] qui est totalement gratuit!

J’ai donc pu l’installer très facilement avec https://certbot.eff.org/[Certbot], un outil qui génère le certificat pour nous et s’occupe même de mettre la configuration Apache à jour.

.Instalation d'un nouveau certificat HTTP pour Apache
[source,bash]
----
$ sudo certbot --apache
----

C’est donc un petit geste mais celui-ci à des répercutions sur la confiances accordée par nos utilisateur et même sur le référencement. Google à d’ailleurs annoncé en août 2014 que le protocole HTTPS serait pris en compte dans l’algorithme de positionnement.

===== Groupe sudo

Comme je l’ai évoqué plus haut, j’ai déjà crée un utilisateur spécifique pour l’application que j’ai rajouté dans le groupe des `sudoers`. Une des actions qui peut être mis en place facilement est de supprimer cet utilisateur du groupe `sudo`. Ceci permet d’éviter l’élévation des privilèges. Un des premier objectif d’un hacker va être de vouloir obtenir des privilèges plus élevé afin de pouvoir effectuer des actions ayant de plus grandes conséquences.

===== Modifier le port par défaut

En regardant les logs d’un serveur, on peut remarquer une quantité importante de tentative de connexion SSH (Le protocole qui permet de se connecter à distance à un ordinateur). Ceci est du au fait que beaucoup de hacker ont mis au point des scripts qui tentent de se connecter en utilisant des dictionnaires de mots de passe.

Par défaut, le port utilisé est le port 22.

===== Blacklister les tentatives de connexions

Comme je l’expliquait plus haut, beaucoup de hacker tentent de se connecter au serveur via la protocole SSH. De la même manière que pour les appels téléphonique, il est possible de bloquer ces tentatives.

https://www.fail2ban.org/wiki/index.php/Main_Page[Fail2ban] est un petit utilitaire écrit en Python qui va s’occuper d’analyser les logs du serveur. Il va donc mettre sur liste noir les adresses IP qui ont tenté de se connecter plusieurs fois avec un mot de passe erroné.

=== Conclusion

Administrer un serveur Linux est un métier à par entière. Je n'estime pas avoir fait tout le travail d'un administrateur système. Entre autre, je n'ai pas utilisé de logiciel de monitoring du serveur Linux et je ne suis donc pas en mesure d'annoncer un temps de disponibilité de l'application. En revanche, je pense que je peux affirmer que j'ai appliqué les pratiques de base dans la sécurisation d'un serveur Linux.

Étant un Linuxien convaincu, cette expérience m'a permis de monter en compétence sur l'administration et la gestion d'un serveur sous Linux. Même si ce n'est pas le cœur de métier de développeur, ce sont réellement des compétences utilise au développeur.
